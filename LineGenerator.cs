using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using IX.Library.Collections;
using JetBrains.Annotations;

namespace Diz.LogWriter;

public class LineGenerator
{
    public ILogCreatorForGenerator LogCreator { get; }
    public Dictionary<string, AssemblyPartialLineGenerator> Generators { get; }
    public LogCreatorLineFormatter LogCreatorLineFormatter { get; }

    public LineGenerator(ILogCreatorForGenerator logCreator, string formatStr)
    {
        LogCreator = logCreator;
        Generators = CreateAssemblyGenerators();
        LogCreatorLineFormatter = new LogCreatorLineFormatter(formatStr, Generators);
    }
        
    public string[] GenerateSpecialLines(string type, int offset = -1, [CanBeNull] TokenExtraContext context = null) => GenerateLines(
            offset: offset, 
            forceGenerateFullLine: LogCreator.Settings.GenerateFullLine, 
            overrideFormatterName: type,
            context: context
        );
    
    public string[] GenerateNormalLines(int offset, [CanBeNull] TokenExtraContext context = null) => GenerateLines(
        offset: offset,
        context: context
    );

    // all tokens generated by a column
    private class ColumnTokens
    {
        public LogCreatorLineFormatter.ColumnFormat ColumnFormat { get; init; }
        public TokenBase[] Tokens { get; init; } = [];
    }

    // optional extra info that can get passed along and used by certain types of generators
    public abstract record TokenExtraContext {}
    public record TokenExtraContextSnes(int SnesAddress) : TokenExtraContext;
    public record TokenExtraContextFilename(string Filename) : TokenExtraContext;

    private string[] GenerateLines(
        int offset, // we could actually stuff this inside the context, but haven't because MOST things want an offset 
        bool forceGenerateFullLine = true, 
        [CanBeNull] string overrideFormatterName = null, 
        [CanBeNull] TokenExtraContext context = null)
    {
        var columnTokens = LogCreatorLineFormatter.ColumnFormats
            .Select(columnFormat => new ColumnTokens {
                ColumnFormat = columnFormat, 
                Tokens = GenerateColumn(offset, columnFormat, overrideFormatterName, context)
            })
            .ToList();

        var mainLineText = "";
        var prependCommentsLines = new List<string>();
        foreach (var columnTokensEntry in columnTokens)
        {
            var columnFormatType = columnTokensEntry.ColumnFormat.Value;
            
            // special case for "labelassign"
            if (overrideFormatterName == "labelassign")
            {
                if (columnFormatType != "code")
                    continue;
                
                var uniform = columnTokensEntry.Tokens.All(x => x is TokenLabelAssign);
                if (!uniform)
                    throw new InvalidDataException("Invalid Emit(): expected all tokens to be TokenLabelAssign here.");

                return columnTokensEntry.Tokens
                    .OfType<TokenLabelAssign>()
                    .Select(token => token.Value)
                    .ToArray();
            }

            // special case for multi-line comments:
            if (columnFormatType == "comment" && string.IsNullOrEmpty(overrideFormatterName))
            {
                var everythingIsAComment = columnTokensEntry.Tokens.All(x => x is TokenComment);
                if (!everythingIsAComment)
                    throw new InvalidDataException("Invalid Emit(): received mix of comment and non-comment tokens.");
                
                var prependCommentsTokens = columnTokensEntry.Tokens
                    .OfType<TokenComment>()
                    .ToList();
                
                // if there's multiple comments for this one line, we'll prepend them all before the line.
                // normally, there will only be one comment per line.
                if (prependCommentsTokens.Count > 1)
                {
                    prependCommentsLines.AddRange(
                        prependCommentsTokens
                            .Select(x => x.Value)
                            .ToList()
                    );
                    
                    // don't process the rest of the line
                    continue;
                }
            }
            
            // non-special-case comment (normal) line processing here:
            var lineTokensForColumn = columnTokensEntry.Tokens
                .OfType<TokenString>()
                .ToList();
            
            if (columnTokensEntry.Tokens.Length != lineTokensForColumn.Count || lineTokensForColumn.Count > 1)
                throw new InvalidDataException("Invalid Emit(): can't have multiple or mismatched tokens per column here.");
            
            var tokenString = lineTokensForColumn.FirstOrDefault();
            var columnFinalText = tokenString?.Value ?? "";
            var lineIsEmpty = string.IsNullOrWhiteSpace(columnFinalText); // [is this right?]
            if (forceGenerateFullLine || columnFormatType == "label" || columnFormatType == "code" || lineIsEmpty)
                mainLineText += columnFinalText;
        }
        
        // cleanup "main" text
        mainLineText = mainLineText.TrimEnd();
        mainLineText = string.IsNullOrEmpty(mainLineText) ? " " : mainLineText;
        
        var prependComments = prependCommentsLines
            .Select(comment => $"; {comment}")
            .ToList();
        
        var result = new List<string>();
        result.AddRange(prependComments);
        result.Add(mainLineText);
        return result.ToArray();
    }

    private TokenBase[] GenerateColumn(int offset, LogCreatorLineFormatter.ColumnFormat columnFormat,
        string overrideFormatterName = null, TokenExtraContext context = null)
    {
        if (columnFormat.IsLiteral) {
            return AssemblyPartialLineGenerator.GenerateFromStr(columnFormat.Value);
        }

        var formatter = SelectFinalColumnFormatter(columnFormat, overrideFormatterName);
        return GenerateColumnTokensFromFormatter(offset, formatter, context);
    }

    private TokenBase[] GenerateColumnTokensFromFormatter(int offset, LogCreatorLineFormatter.ColumnFormat columnFormat, TokenExtraContext context = null)
    {
        var columnGenerator = GetGeneratorFor(columnFormat.Value);
        var sanitizedOffset = columnFormat.SanitizeOffset(offset);
        
        return columnGenerator.GenerateTokens(sanitizedOffset, columnFormat.LengthOverride, context);
    }

    private LogCreatorLineFormatter.ColumnFormat SelectFinalColumnFormatter(LogCreatorLineFormatter.ColumnFormat columnFormat, string overrideName = null)
    {
        return overrideName != null 
            ? BuildSpecialFormatterFrom(columnFormat, overrideName) 
            : columnFormat;
    }

    private LogCreatorLineFormatter.ColumnFormat BuildSpecialFormatterFrom(LogCreatorLineFormatter.ColumnFormat originalColumn, string specialModifierStr)
    {
        var ignoreOffset = false;
        string val;
        if (originalColumn.Value != "code")
        {
            ignoreOffset = true;
            val = "%empty";
        }
        else
        {
            val = $"%{specialModifierStr}";
        }

        return new LogCreatorLineFormatter.ColumnFormat
        {
            LengthOverride = originalColumn.LengthOverride ?? GetGeneratorFor(originalColumn.Value).DefaultLength,
            IgnoreOffset = ignoreOffset,
            Value = val,
        };
    }

    public AssemblyPartialLineGenerator GetGeneratorFor(string parameter)
    {
        if (!Generators.TryGetValue(parameter, out var generator))
            throw new InvalidOperationException($"Can't find generator for {parameter}");
        
        return generator;
    }
        
    public Dictionary<string, AssemblyPartialLineGenerator> CreateAssemblyGenerators()
    {
        var generators = AssemblyGeneratorRegistration.Create();
        generators.ForEach(kvp => kvp.Value.LogCreator = LogCreator);
        return generators;
    }
}